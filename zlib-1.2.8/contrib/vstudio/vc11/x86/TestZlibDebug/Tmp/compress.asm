; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	D:\vs_project\zlib-1.2.8\compress.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG85370 DB	'1.2.8', 00H
_DATA	ENDS
PUBLIC	_compress@16
PUBLIC	_compress2@20
PUBLIC	_compressBound@4
EXTRN	_deflate@8:PROC
EXTRN	_deflateEnd@4:PROC
EXTRN	_deflateInit_@16:PROC
; Function compile flags: /Odtp
; File d:\vs_project\zlib-1.2.8\compress.c
_TEXT	SEGMENT
_sourceLen$ = 8						; size = 4
_compressBound@4 PROC

; 77   : {

	push	ebp
	mov	ebp, esp

; 78   :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 79   :            (sourceLen >> 25) + 13;

	mov	eax, DWORD PTR _sourceLen$[ebp]
	shr	eax, 12					; 0000000cH
	add	eax, DWORD PTR _sourceLen$[ebp]
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	shr	ecx, 14					; 0000000eH
	add	eax, ecx
	mov	edx, DWORD PTR _sourceLen$[ebp]
	shr	edx, 25					; 00000019H
	lea	eax, DWORD PTR [eax+edx+13]

; 80   : }

	pop	ebp
	ret	4
_compressBound@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs_project\zlib-1.2.8\compress.c
_TEXT	SEGMENT
_stream$ = -64						; size = 56
tv77 = -8						; size = 4
_err$ = -4						; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_level$ = 24						; size = 4
_compress2@20 PROC

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 29   :     z_stream stream;
; 30   :     int err;
; 31   : 
; 32   :     stream.next_in = (z_const Bytef *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _stream$[ebp], eax

; 33   :     stream.avail_in = (uInt)sourceLen;

	mov	ecx, DWORD PTR _sourceLen$[ebp]
	mov	DWORD PTR _stream$[ebp+4], ecx

; 34   : #ifdef MAXSEG_64K
; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : #endif
; 38   :     stream.next_out = dest;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _stream$[ebp+12], edx

; 39   :     stream.avail_out = (uInt)*destLen;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _stream$[ebp+16], ecx

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

	mov	edx, DWORD PTR _destLen$[ebp]
	mov	eax, DWORD PTR _stream$[ebp+16]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN3@compress2
	mov	eax, -5					; fffffffbH
	jmp	$LN4@compress2
$LN3@compress2:

; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;

	mov	DWORD PTR _stream$[ebp+32], 0

; 43   :     stream.zfree = (free_func)0;

	mov	DWORD PTR _stream$[ebp+36], 0

; 44   :     stream.opaque = (voidpf)0;

	mov	DWORD PTR _stream$[ebp+40], 0

; 45   : 
; 46   :     err = deflateInit(&stream, level);

	push	56					; 00000038H
	push	OFFSET $SG85370
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	lea	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_deflateInit_@16
	mov	DWORD PTR _err$[ebp], eax

; 47   :     if (err != Z_OK) return err;

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN2@compress2
	mov	eax, DWORD PTR _err$[ebp]
	jmp	SHORT $LN4@compress2
$LN2@compress2:

; 48   : 
; 49   :     err = deflate(&stream, Z_FINISH);

	push	4
	lea	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_deflate@8
	mov	DWORD PTR _err$[ebp], eax

; 50   :     if (err != Z_STREAM_END) {

	cmp	DWORD PTR _err$[ebp], 1
	je	SHORT $LN1@compress2

; 51   :         deflateEnd(&stream);

	lea	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	_deflateEnd@4

; 52   :         return err == Z_OK ? Z_BUF_ERROR : err;

	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN6@compress2
	mov	DWORD PTR tv77[ebp], -5			; fffffffbH
	jmp	SHORT $LN7@compress2
$LN6@compress2:
	mov	edx, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv77[ebp], edx
$LN7@compress2:
	mov	eax, DWORD PTR tv77[ebp]
	jmp	SHORT $LN4@compress2
$LN1@compress2:

; 53   :     }
; 54   :     *destLen = stream.total_out;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _stream$[ebp+20]
	mov	DWORD PTR [eax], ecx

; 55   : 
; 56   :     err = deflateEnd(&stream);

	lea	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_deflateEnd@4
	mov	DWORD PTR _err$[ebp], eax

; 57   :     return err;

	mov	eax, DWORD PTR _err$[ebp]
$LN4@compress2:

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_compress2@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs_project\zlib-1.2.8\compress.c
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_compress@16 PROC

; 67   : {

	push	ebp
	mov	ebp, esp

; 68   :     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);

	push	-1
	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _destLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	_compress2@20

; 69   : }

	pop	ebp
	ret	16					; 00000010H
_compress@16 ENDP
_TEXT	ENDS
END
